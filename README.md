<h1 align="center">大作业：葫芦娃大战蛇蝎精</h1>

<h3 align="center">罗雯波-151220068</h3>

[TOC]

## 应用概述

本次实验使用JAVA实现一个GUI应用，展示**葫芦娃大战蛇蝎精**的过程。应用运行流程如下：

1. 启动应用，展示空白页面，等待用户按键
2. 用户按下**L**或**空格**：
   1. 按下L：弹出文件选择框，读取用户所选文件进行战斗记录回放
   2. 按下空格：开始新的战斗
3. 葫芦娃战队和蛇蝎精战队分别从左右两边向对方行进，接触后进行战斗
4. 战斗至某一方全灭，等待用户按键
5. GOTO 2.

需要补充的是，通过点击关闭按钮可以使应用退出。

## 概要设计

### 包结构

项目主要有3个包：cs.lwb.gui、cs.lwb.huluwa（包括cs.lwb.huluwa.creature)、cs.lwb.log。其中gui包的职责主要是应用界面交互的设置和响应，huluwa包的职责是实现葫芦娃大战蛇蝎精的战斗过程，log包的职责是对战斗记录的输出和读取。

### 类结构

在gui包中，有一个简单的接口Drawable，所有生物都需要实现这个接口；主窗口类MainFrame继承自JFrame，对界面进行了设置；战斗面板WarPanel继承自JPanel，作为展示战斗画面的画布，并管理葫芦娃世界的运行。

在log包中，Logger实现了输出到控制台的日志；InputRecord和OutputRecord则分别是处理读入和写出战斗记录流的类。

huluwa包（这里包括huluwa.creature包)是模拟整个战斗过程的核心模块。

- 抽象类God是葫芦娃世界的管控者，负责生物的初始化，检查它们的运动、攻击、死活等状态，每一个生物的所有动作都会被God知晓并进行相应处理，每个生物可以通过与God交互连接其它生物的状态。从设计模式的角度说，God是观察者。除此之外，God还负责与WarPanel的交互，实现葫芦娃世界的绘图显示。
- GodWithInputRecord和GodWithOutputRecord继承自God，分别实现了读入战斗记录并回放以及将战斗细节写出到记录文件。
- 抽象类Creature模拟一个生物的整个生命过程，包括生成、移动、攻击、死亡等等，根据要求Creature实现了Runnable接口，以更好模拟葫芦娃世界的运行。内部包含了CreatureState、Faction、Speed、Capability等Enum类型，用以描述生物的状态、阵营、速度、战斗能力等不同的属性。
- 在huluwa.creature包中是抽象类Creature的具体实现，关于生物的共性基本上都在Creature中实现了，具体实现中需要补充的主要是不同的外观（getImage方法）和不同的行为（onTick方法），以及对生物基本属性（阵营，名字，速度，战斗能力）进行设置。
- Attack类用于模拟生物之间的一次攻击过程，实现了Runnable接口，使得生物之间的一次攻击是有过程而不是瞬时的。
- Ground类用于放置生物，管理生物的位置，并负责不同阵营生物的遭遇战发生条件判断。
- Location类用于描述生物的位置。

最后补充的是，根据要求将应用入口设置在Main类里面，Main不在默认包里而在cs.lwb包里。

### 模块协作

在这里对整个应用执行时各个模块如何进行相互协作进行说明。

1. 初始时，在Main中启动了MainFrame。MainFrame监听用户按键，并根据按键传入参数启动WarPanel。
2. WarPanel根据参数选择生成GodWithInputRecord或者GodWithOutputRecord，战斗开始。
3. God初始化各个生物，放置到Ground中，并让他们开始运行（并发），如果是战斗回放则生物的线程不会启动，他们的行为由God来指挥（这部分实现由GodWithInputRecord来改写）。
   1. 如果不是战斗回放，则生物的运动是多线程的，每次运动了之后生物都要报告God其行为（观察者模式），God会检查其是否与敌对阵营的生物发生遭遇，如果是，则会通知其发起攻击，然后会启动一个Attack线程，模拟一次攻击的过程，并绘制攻击的轨迹。Attack线程结束则一次攻击结束，生物将继续运行。如果有生物死亡，同样也要通知God，God将会更新Ground的状态。在GodWithOutputRecord中，对几个关键的状态更新的方法进行了补充，将生物的行为写出到记录文件。这里还设置了定时器，每0.1秒打一个时间戳，使得回放时能够重现时间的平滑流逝。
   2. 如果是战斗回放，则生物的运动是由God统一指挥的。具体实现由GodWithInputRecord重写，在start方法中不启动各个生物的线程，而是设置定时器，每0.1秒读入一段生物行为记录（读到当前时间戳为止），然后由God指挥各个生物复现这些行为。
4. 战斗结束后（某一阵营全灭），God将running标志设置为false，然后MainFrame可以继续接收键盘消息，开始新的战斗。

## 具体实现

前面说明了整个应用的概要设计，大体的实现已经说明，这里主要是对一些细节进行补充说明。

### 生物的属性和行为

抽象类Creature中设置了若干属性域，具体的子类需要对它们进行设置，这些属性包括：阵营（faction）、名字（name）、血量（healthPoints）、速度（speed）、攻击力（hitPoints）。

生物的行为有统一的框架，具体实现是run方法里面的while循环，通过反复地sleep一段时间（时间间隔由speed）决定，然后调用onTick方法，执行某个操作。onTick方法为抽象接口，由子类实现，现在的实现中各个生物的onTick行为比较简单，就是朝敌对方前进。

### 攻击的实现

为了将攻击模拟成一段过程而不是某个瞬间就结束的操作，Attack实现了Runnable接口。具体实现把攻击分成了10个阶段，通过在for循环内sleep实现各个阶段递进变化。10个阶段结束后，本次攻击就结束了，攻击者将会通知God这个变化，由God来进行后续的动作指导。

值得注意的是，我将攻击实现为了动画，一次攻击会由攻击者发射一道“光波”飞向被攻击者对其进行打击。实现方式就是在绘图时检查Attack处于哪个阶段，然后相应地在攻击者和被攻击者之间的某个节点上画出一道“光波”，由于Attack是单独的一个线程，每次sleep后都会更新其阶段，并通知God需要repaint，通过画面的不断刷新就实现了动画的效果。

### God作为观察者

God作为葫芦娃世界的掌控者，需要观察每个生物的行动细节。在具体实现中，有若干checkXXX方法（例如checkMove），这些方法的作用有两个：一是由Creature调用，通知God自己的行动细节；二是由God的子类重写，以记录每个生物的行动记录。

- Creature在每次移动之后，都会报告checkMove，God将会更新其在Ground中的位置，以记录其位置变化。而后调用checkDistance检查其是否与敌方生物遭遇。若发生遭遇，则通知Creature对敌方生物进行攻击，然后调用checkAttack（设计这个接口主要用于子类的重写以实现对攻击行为的记录）。生物如果死亡，会通知God（checkDeath），God将会进行相应的更新。
- GodWithInputRecord由于是读取记录并回放，不需要关注各个check方法，而GodWithOutputRecord为了记录各个生物的行为序列，则需要重写checkMove和checkAttack等方法，将生物的行为输出到记录文件。

### 战斗的随机性来源

在葫芦娃世界中，不同的生物具有不同的属性，使得它们的战斗力有所不同，但是战斗结果仍然呈现了多样性，因为这其中有随机的因素。

1. 每个Creature都是一个线程，而线程的运行先后次序是不定的，如果某次战斗中一方阵营大部分生物都被首先执行，则会首先对敌方造成大量伤害，取得显著优势。同时，Attack是用线程实现的，并不能保证sleep一段时间后会立刻被调入执行，使得某次攻击可能被延迟，也会影响战斗结果。
2. God在判断两个阵型的生物遭遇时，调用了Ground的getCreatureNearby在寻找攻击范围内的生物，为了增加战斗的随机性和观赏性，如果存在多个在攻击范围内的生物，这里将随机选取一个返回，使得生物的攻击目标变得不确定。理论上说，一方阵营的最优策略应该是集火对面的某一个生物，但是这里的随机性使得攻击可能恰好集火也可能恰好分摊，让战斗结果变得不可预测。

## 问题解决

在本次大作业中遇到了不少问题，通过分析和解决这些问题有了许多收获，在这里列举一部分。

### Creature线程间竞争

由于每个Creature都是一个线程，每个生物的动作都是异步，并且它们执行了某个动作后向God发送报告的消息也是异步的，使得可能发生某个生物已经移动了，但是在向God报告的过程中被其它生物的线程打断了的情况，接着另一个生物在God中获取到的信息就成了未更新的信息，使得战斗过程变得混乱，例如向攻击范围外的生物进行攻击、已经死了的生物仍在攻击或是被攻击等。为了解决这个问题，我将God的若干checkXXX方法（这些方法可能导致状态更新）都设置成了synchronized，让一个生物在报告某个行为的时候不能被打断。同时在Creature中将onTick方法的调用置于synchronize(god)体内，使得多个生物不会同时处于执行动作的过程中，规避了多线程之间不安全的竞争问题。

### 写出记录文件时的多线程竞争

记录文件的内容有两部分：时间戳和动作流。动作流的记录实现是ObjectStream，多个Object之间可能是连续的。而时间戳的记录是由Timer来负责的，使得在写多个逻辑上连续不可分的Object时可能被打断去写入时间戳，这就会使记录文件损坏。我通过检查出错点和异常信息，发现了这个问题，并将写入多个连续不可分Object的方法设置为synchronized，解决了这个问题。

### Swing Dialog的问题

为了显示消息，我调用了JOptionPane.showMessageDialog方法，在测试过程中发现有时会出现消息弹框空白且无法响应任何操作的情况，这时只能通过任务管理器来关闭程序。通过查询网上资料，了解到Swing的控件是多线程不安全的，最好通过SwingUtilities.invokeLater来启动一个消息弹框，通过这个方法可以解决问题。

### Maven构建的问题

最后使用Maven进行构建时，我发现生成的程序运行会出错，与直接通过Intellij运行的不一致。仔细检查后发现是字符编码的问题，Maven构建时默认地会用本地字符编码，我在win10上构建则使用了GBK编码，造成资源文件读取错误。通过查阅资料对Maven的构建时编码进行了设置后解决问题。

## 补充说明

### 单元测试

Ground类作为放置Creature的容器类，不仅有set和get方法，还包括一个寻找某个范围内的敌方生物方法实现，为了保障其正确性，我编写了测试用例来测试其方法，使用的是junit框架。

### 记录文件

每次战斗结束，记录文件将会保存到应用的执行目录下，文件名为“时-分-秒_(年.月.日).huluwa”。作为提交的精彩战斗回放被命名为“精彩回放.huluwax”。